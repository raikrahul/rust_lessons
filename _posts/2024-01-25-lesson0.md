---
layout: default
title: "Lesson 0: Hello World in Rust"
date: 2024-01-25
categories: rust
permalink: /lesson0/
---

# Lesson 0: Hello World in Rust üåü

Welcome to the very first lesson of **Rust Lessons**! In this tutorial, we'll create your first Rust program: the famous "Hello, World!" Let's get started.

---

## üìù What You'll Learn
By the end of this lesson, you'll understand:
- How to write and run a simple Rust program.
- The basic structure of a Rust application.

---

## üöß Prerequisites
Make sure you have:
- Installed Rust on your system. If not, follow the [official Rust installation guide](https://www.rust-lang.org/tools/install).

---

## ‚ú® Writing Your First Program

Here‚Äôs the simplest program in Rust:


```rust


use std::env; // (1) Import the `env` module from the standard library -  like importing a toolbox (env) from a larger workshop (std) . This module provides functions to interact with the environment, such as accessing command-line arguments.  Imagine each function in `env` as a specialized tool for environment interaction. We anticipate using `env::args` to retrieve command-line arguments, crucial for a program designed to process files given as input.

use std::fs::File; // (2) Import the `File` struct from the `fs` (file system) module within the standard library. Think of `File` as a blueprint for representing files on the operating system.  This import brings in the ability to work with files ‚Äì opening, creating, reading, writing etc.  We expect to utilize `File::open` to access the source file and `File::create` to make the destination file.

use std::io::{self, Read, Write}; // (3) Import the `io` module, and specifically `Read` and `Write` traits. `io` is like the 'input/output' department of the standard library, providing core functionalities for reading and writing data. `self` within the curly braces brings the `io` module itself into scope, potentially for functions within `io` not specifically listed. `Read` and `Write` are not concrete types, but traits ‚Äì like interfaces or contracts ‚Äì defining behaviors for reading from and writing to streams of data. Files, in Rust's I/O model, are treated as streams. These traits will allow us to interact with the opened files.

use std::process; // (4) Import the `process` module, which allows control over the current process.  Imagine `process` as the program's internal control panel.  We are particularly interested in `process::exit`, a function to immediately terminate the program execution, especially when unrecoverable errors occur, ensuring the program doesn't proceed in a broken state.

const BUF_SIZE: usize = 256; // (5) Declare a constant named `BUF_SIZE` of type `usize` (unsigned size, platform-dependent integer type). It's initialized to 256. This constant represents the size, in bytes, of the buffer used for reading and writing file content. A buffer is a temporary holding space in memory.  256 bytes = 256 * 8 bits = 2048 bits = 0.25 KB = 256 / (1024 * 1024) MB ‚âà 0.000244 MB. Choosing 256 as the buffer size implies a balance between memory usage and read/write operations per system call.  Smaller buffer may lead to more frequent, smaller I/O operations; Larger buffers potentially reduce system call overhead but consume more memory per operation. This `BUF_SIZE` acts as a chunk size when we read from the input and write to the output file - processing the file in segments of 256 bytes.

fn main() { // (6) Define the `main` function. This is the entry point of the Rust program ‚Äì where execution begins. It's like the front door of the program. It takes no arguments and returns nothing explicitly (implicitly returns `()`, the unit type). Everything within these curly braces is the core logic of our file copy program.

    let args: Vec<String> = env::args().collect(); // (7) Declare a mutable variable named `args`. Its type is explicitly annotated as `Vec<String>` ‚Äì a vector (dynamically sized array) of Strings. This line collects the command-line arguments passed to the program when it's executed. `env::args()` is an iterator that yields each command-line argument as a String. `.collect()` method on the iterator gathers all these strings into a `Vec<String>`. For example, if you run the program as `my_copy program.txt destination.txt`, then `args` will contain ["my_copy", "program.txt", "destination.txt"].  `args.len()` will be 3, `args[0]` will be "my_copy" (the program's name), `args[1]` "program.txt", and `args[2]` "destination.txt".

    if args.len() != 3 { // (8) Start of an `if` statement, a conditional control flow block. This checks if the number of command-line arguments is not equal to 3. `args.len()` returns the number of elements in the `args` vector. For correct usage, we expect 3 arguments: the program name, the source file path, and the destination file path.

        eprintln!("Usage: {} file1 file2", args[0]); // (9) If the condition in (8) is true (wrong number of arguments), this line executes. `eprintln!` is a macro for printing to standard error (stderr). It outputs a usage message. `{}` are placeholders for formatting. `args[0]` will be the program name, `file1` and `file2` are placeholders to indicate expected input and output file arguments.  If the program name were "my_copy", this would print: "Usage: my_copy file1 file2" to standard error, signaling incorrect usage to the user ‚Äì like an error message whispered to the user in a side channel without disrupting the main output stream.

        process::exit(1); // (10) If the condition in (8) is true, this line executes immediately after (9). `process::exit(1)` terminates the program with an exit code of 1.  Exit codes signal to the calling environment (e.g., the shell) whether the program ran successfully (usually 0) or with errors (non-zero). Exit code 1 conventionally indicates a general error or invalid arguments in this context ‚Äì like saying "program terminated because of bad input arguments, code: 1".

    } // (11) End of the `if` block from (8).

    let mut in_file = match File::open(&args[1]) { // (12) Declare a mutable variable `in_file` to hold the opened input file. The type will be inferred as `File`. This line uses a `match` expression, a powerful control flow structure for handling results that might be either successful (Ok) or erroneous (Err). `File::open(&args[1])` attempts to open the file specified by the path in `args[1]` (the second command-line argument, expected to be the source file path).  `&args[1]` creates a reference (pointer) to the String at `args[1]`, as `File::open` expects a path reference.

        Ok(file) => file, // (13) This is the first arm of the `match` expression in (12). If `File::open` is successful, it returns `Ok(file)`, where `file` is the opened `File` object. This arm extracts the `file` from the `Ok` variant and assigns it to the `in_file` variable.  This path represents the 'happy path' - successfully opening the input file and making it ready for reading ‚Äì like receiving the 'key' (file handle) to the 'treasure chest' (input file).

        Err(err) => { // (14) This is the second arm of the `match` expression in (12). If `File::open` fails (e.g., file not found, permission denied), it returns `Err(err)`, where `err` is an `io::Error` object describing the error. This arm handles the error scenario. `err` variable here holds information about why file opening failed - like receiving a message 'treasure chest locked: permission denied'.

            eprintln!("{}: {}", args[1], err); // (15) Inside the error arm (14), this line executes if `File::open` failed. It prints an error message to standard error using `eprintln!`. It displays the file path from `args[1]` followed by the error message `err` obtained from `File::open`. For example, if `program.txt` doesn't exist, it might print: "program.txt: No such file or directory" - informing the user *which* file had a problem and *what* the problem was.

            process::exit(2); // (16)  Also inside the error arm, after printing the error message, `process::exit(2)` terminates the program with exit code 2. Exit code 2 typically indicates an error related to input files, specifically problems opening the source file in this case ‚Äì like signaling "program terminated because input file access problem, code: 2".

        } // (17) End of the error arm from (14).
    }; // (18) End of the `match` expression from (12).

    let mut out_file = match File::create(&args[2]) { // (19) Similar to (12), declare a mutable variable `out_file` to hold the opened output file. This uses `File::create(&args[2])` to attempt to *create* a file at the path specified by `args[2]` (the third command-line argument, expected to be the destination file path). If a file with this name already exists, `File::create` will truncate (empty) it. Again, `&args[2]` provides a path reference.

        Ok(file) => file, // (20) Success arm for `File::create`, same logic as (13). If file creation is successful, the opened `File` object is assigned to `out_file`. This represents the 'happy path' for output file ‚Äì like acquiring permission to create a new 'treasure chest' (output file) or to overwrite the old one, ready for writing.

        Err(err) => { // (21) Error arm for `File::create`, analogous to (14). If file creation fails (e.g., no permission to create in the directory, disk full), `File::create` returns `Err(err)`.  This handles cases like not having permission to plant the 'treasure chest' (output file) in the given location.

            drop(in_file); // (22) Inside the error arm for output file creation, `drop(in_file)` is called.  `drop` explicitly closes the `in_file`.  This is important because if we failed to create the output file, we should clean up resources already acquired, in this case, close the already opened input file descriptor.  Think of it as putting the 'key' (file handle for input) back, since the whole operation is failing. Even though Rust would automatically drop `in_file` when it goes out of scope, explicitly dropping it makes the intent clear and might be important in more complex error handling scenarios or if the order of resource release is critical in certain edge cases.

            eprintln!("{}: {}", args[2], err); // (23)  Still in the output file error arm, similar to (15), print an error message to stderr. It displays the output file path from `args[2]` and the error `err` from `File::create`.  e.g., "destination.txt: Permission denied" - user gets informed which file had problems and why.

            process::exit(3); // (24) Still within the error arm, `process::exit(3)` terminates the program with exit code 3. Exit code 3 convention indicates problem with output file creation ‚Äì like signaling "program terminated due to output file issue, code: 3".

        } // (25) End of error arm from (21).
    }; // (26) End of `match` expression from (19).

    let mut buffer = [0u8; BUF_SIZE]; // (27) Declare a mutable variable `buffer`. Its type is an array of 256 unsigned 8-bit integers (`u8`), initialized to all zeros `[0u8; BUF_SIZE]`.  This is our buffer ‚Äì a temporary holding space for reading chunks of data from the input file before writing them to the output file. `BUF_SIZE` is 256, so `buffer` can hold 256 bytes at a time. It's like a small cart to carry pieces of 'treasure' (file data) from the input to output 'treasure chest'.

    loop { // (28) Start of an infinite `loop`.  This is the core reading and writing loop that continues until explicitly broken out of (in this case, when the input file is exhausted). Think of it as a perpetual cycle of operations.

        let bytes_in = match in_file.read(&mut buffer) { // (29) Inside the `loop`, declare a variable `bytes_in` to store the number of bytes read in each iteration. Another `match` expression handles the result of `in_file.read(&mut buffer)`. `in_file.read(&mut buffer)` attempts to read data from `in_file` and store it in `buffer`.  `&mut buffer` provides a mutable reference to our buffer so `read` can write data into it. `read` returns a `Result<usize>`, indicating success (Ok with the number of bytes read, `usize` type) or failure (Err with an `io::Error`).

            Ok(n) => n, // (30) Success arm of `in_file.read`. If `read` is successful, `Ok(n)` is returned, where `n` is the number of bytes read. This arm extracts `n` and assigns it to `bytes_in`.  `n` can range from 0 to `BUF_SIZE` (256) or less if we reach the end of file. If `n` is 0, it means we've reached the end of the input file.

            Err(err) => { // (31) Error arm of `in_file.read`. If `read` fails (e.g., disk read error), `Err(err)` is returned.

                eprintln!("Error reading file: {}", err); // (32) Error handling within the `read` error arm. Prints an error message to stderr indicating a read error, along with the error `err`.  Informs user of problem during data retrieval from source.

                process::exit(4); // (33) Still in error arm, `process::exit(4)` terminates the program with exit code 4, indicating a general I/O error during file operation ‚Äì like "program ended due to read error, code: 4".

            } // (34) End of error arm of `in_file.read`.
        }; // (35) End of `match` expression for `in_file.read`.

        if bytes_in == 0 { // (36) Conditional statement. Checks if `bytes_in` is equal to 0. As explained in (30), `bytes_in == 0` indicates the end of the input file has been reached ‚Äì no more bytes were read because there are no more bytes to read.

            break; // (37) If `bytes_in == 0` is true, `break` statement is executed. This breaks out of the innermost `loop` (loop started in (28)). This is the loop termination condition ‚Äì when the whole input file has been processed ‚Äì signaling "mission complete for reading!".

        } // (38) End of `if` block from (36).

        if let Err(err) = out_file.write_all(&buffer[..bytes_in]) { // (39) Another error handling construct ‚Äì `if let Err(...) = ...`.  `out_file.write_all(&buffer[..bytes_in])` attempts to write data to `out_file`. `&buffer[..bytes_in]` creates a slice of the `buffer` containing only the bytes that were actually read in the last `in_file.read` operation (from index 0 up to `bytes_in`). `write_all` is important because it keeps trying to write all provided bytes and only returns `Err` if write fails completely. If `write_all` returns `Err(err)` (write failed, e.g., disk full, write permission problem), the condition in `if let Err` is met.

            eprintln!("Fatal write error: {}", err); // (40) Error handling in case `write_all` fails. Prints an error message to stderr indicating a critical write error along with the error `err` - alerts user to problem when storing data to destination.

            process::exit(4); // (41) If write fails, `process::exit(4)` terminates the program with exit code 4 ‚Äì reusing the same exit code as for read errors, implying a general I/O issue, now during write ‚Äì signaling "program terminated because write problem, code: 4".

        } // (42) End of `if let Err` block.

    } // (43) End of the `loop` from (28). Once the `break` in (37) is hit and the loop is finished, execution reaches here. At this point, file copying is complete if no errors occurred within the loop.  If program reached here, it's assumed the file has been successfully copied, like finishing the data transport task.

} // (44) End of the `main` function (6).  Program execution naturally exits after completing all statements in `main` if no `process::exit` was encountered, implicitly returning an exit code of 0 to the operating system, indicating successful program completion ‚Äì silent 'mission accomplished' message.







 
```