---
layout: default
title: "Lesson 0: CP "
date: 2024-01-25
categories: rust
permalink: /lesson0/
---

# Lesson 0: CP


```rust


use std::env;        // (1) Imports `env` module. Compiler resolves this
                      //     at compile time. Creates dependency link
                      //     to `std` library. No runtime cost directly.
use std::fs::File;   // (2) Imports `File` struct. Compile-time symbol
                      //     resolution. `File` is an abstraction over OS
                      //     file descriptors. System calls at  the backend.
use std::io::{self, Read, Write}; // (3) Imports `io` module and traits. `self` brings
                                   //     module in scope. `Read`, `Write` traits are
                                   //     interfaces. Enables polymorphism via traits.
use std::process;    // (4) Imports `process` module. For process control
                      //     functions like `exit`. Uses OS system calls to
                      //     terminate the current running process.

const BUF_SIZE: usize = 256; // (5) `usize` is platform-dependent integer type.
                             //     Compiler replaces `BUF_SIZE` with `256` at
                             //     compile time. Inlined constant. Memory ops
                             //     use platform native word size for indexing.

fn main() {          // (6) Program entry point. Compiler generates machine
                      //     code starting here. Runtime calls `main`. Stack
                      //     frame for `main` is allocated on function entry.
    let args: Vec<String> = env::args().collect(); // (7) `env::args()` retrieves OS command line args.
                                                    //     Heap allocation for `Vec<String>`. `collect()`
                                                    //     drives iterator, building `Vec`. `String`s
                                                    //     themselves are dynamically allocated on heap.
    if args.len() != 3 {     // (8) `args.len()` is O(1) vector length access.
                             //     Comparison against `3` is single CPU instruction.
                             //     CPU branch prediction attempts to optimize.
                             //     Misprediction causes pipeline flush, perf hit.
        eprintln!("Usage: {} file1 file2", args[0]); // (9) `eprintln!` macro writes to stderr (fd 2).
                                                     //     Uses buffered I/O internally. Involves kernel
                                                     //     `write(2)` syscall. Formatting before syscall.
        process::exit(1);   // (10) `process::exit(1)` terminates program immediately.
                             //      OS reclaims process resources. Exit code `1`
                             //      signals error to shell/parent process. Kernel op.
    }

    let mut in_file = match File::open(&args[1]) { // (11) `File::open()` attempts to open input file.
                                                    //      Invokes OS `open(2)` syscall. Kernel checks
                                                    //      permissions and file existence. Allocates file
                                                    //      descriptor, wrapped in `File` struct.
        Ok(file) => file,                       // (12) `Ok(file)` means file opened successfully. `file`
                                                    //      (File struct) moved to `in_file`. No heap alloc
                                                    //      here. Just moves the File struct, owns fd.
        Err(err) => {                            // (13) `Err(err)` file open failure. `err` is `io::Error`.
                                                    //      Contains OS error details. Error handling path.
            eprintln!("{}: {}", args[1], err);    // (14) `eprintln!` macro to stderr for error message.
                                                     //      Outputs filename and OS error description.
            process::exit(2);                   // (15) `process::exit(2)` terminates with exit code 2.
                                                     //      Signals file open error. Kernel cleanup.
        }
    };

    let mut out_file = match File::create(&args[2]) { // (16) `File::create()` attempts to create/open output.
                                                     //      OS `open(2)` syscall with `O_CREAT|WRONLY|TRUNC`.
                                                     //      Kernel handles file creation, permissions. FD alloc.
        Ok(file) => file,                        // (17) `Ok(file)` output file created/opened. `file` moved.
                                                     //      `out_file` now owns output file descriptor.
        Err(err) => {                             // (18) `Err(err)` output file create/open failed. Error path.
            drop(in_file);                       // (19) `drop(in_file)` explicitly closes input file. RAII.
                                                     //      `close(2)` syscall releases input file descriptor.
                                                     //      Kernel reclaims fd resource. Important cleanup.
            eprintln!("{}: {}", args[2], err);     // (20) `eprintln!` macro to stderr. Output file error.
                                                     //      Filename and OS error description output.
            process::exit(3);                    // (21) `process::exit(3)` terminates with exit code 3.
                                                     //      Signals output file error. Kernel cleanup.
        }
    };

    let mut buffer = [0u8; BUF_SIZE]; // (22) `[0u8; BUF_SIZE]` fixed-size byte array on stack.
                                      //      `BUF_SIZE` (256) bytes allocated contiguously
                                      //      in stack frame. Fast allocation, stack based.
                                      //      Zero-initialized by default in Rust.

    loop {                               // (23) `loop` initiates infinite loop. Compiler might
                                         //      optimize to simple jump if loop body is simple.
                                         //      Branch predictor will favor loop continuation.
        let bytes_in = match in_file.read(&mut buffer) { // (24) `in_file.read(&mut buffer)` reads from input file.
                                                         //      `read(2)` syscall invoked. Kernel reads up to
                                                         //      `BUF_SIZE` bytes from file into `buffer`.
                                                         //      Blocking syscall if no data available.
            Ok(n) => n,                                // (25) `Ok(n)` successful read, `n` bytes read count.
                                                         //      `n` is the number of bytes actually read from file.
            Err(err) => {                              // (26) `Err(err)` file read error. Error handling path.
                eprintln!("Error reading file: {}", err); // (27) `eprintln!` to stderr. Read error message.
                                                          //      Generic read error and OS error details.
                process::exit(4);                      // (28) `process::exit(4)` terminates with exit code 4.
                                                          //      Signals file read error. Kernel cleanup.
            }
        };

        if bytes_in == 0 {                      // (29) `bytes_in == 0` checks for EOF (end of file).
                                                 //      Comparison with zero. If true, EOF reached.
                                                 //      Loop termination condition met in this case.
            break;                             // (30) `break` exits the `loop`. Control flow jumps
                                                 //      out of the loop block. Loop terminates here.
        }

        if let Err(err) = out_file.write_all(&buffer[..bytes_in]) { // (31) `out_file.write_all()` writes to output file.
                                                                     //      `write(2)` syscall invoked. Kernel writes `bytes_in`
                                                                     //      bytes from `buffer` to output file. Blocking call.
                                                                     //      `write_all` handles partial writes, ensures all sent.
            eprintln!("Fatal write error: {}", err);    // (32) `eprintln!` to stderr. Write error message.
                                                          //      Indicates critical write failure to output.
            process::exit(4);                           // (33) `process::exit(4)` terminates with exit code 4.
                                                          //      Signals file write error. Kernel cleanup.
        }
    }                                          // (34) End of `loop` block. Loop continues until break.
}                                              // (35) End of `main` function. Stack frame unwinding.
                                                 //      Normal program exit (code 0) if no `exit()` called.


```


### Exercise 

Let us do byte by byte copy, exactly one byte. Read exactly one, write exactly one. No more and no less. 