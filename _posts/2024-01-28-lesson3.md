```rust
layout: default
title: "Lesson 3: Structs and Enums in Rust"
date: 2024-01-28
categories: rust
permalink: /lesson3/
---

# Lesson 3: Structs and Enums in Rust 🏗️

Learn how to create custom data types in Rust using structs and enums, essential for organizing complex data.

---

## 📝 What You'll Learn
- Define and use structs
- Implement methods on structs
- Create and match enums
- Combine structs and enums

---

## 🏛️ Defining Structs

```rust
// Define a struct named 'User' (1).
struct User {
    username: String, // User's username (1.1). Data type String (UTF-8 encoded text, dynamically sized). Allocates memory on the heap to store the username.
                     // For example, if username is "RustBeginner", it will occupy 12 bytes + overhead for String metadata on the heap, roughly estimated as 12 (characters) * 1 byte/char (ASCII approximation) + 8 bytes (capacity) + 8 bytes (length) + 8 bytes (pointer to heap buffer) = ~36 bytes.
                     // Edge case: Very long usernames (e.g., 1MB) could lead to increased memory usage and potentially slower string operations.
    email: String, // User's email address (1.2). Data type String.  Similar memory characteristics as username. If email is "user123@example.com", approximately 19 * 1 + 24 = ~43 bytes.
                    //  Input validation is crucial here; invalid email formats might cause issues if this data is used in external systems or APIs later.
    sign_in_count: u64, // Number of times user has signed in (1.3). Data type u64 (unsigned 64-bit integer). Range: 0 to 2^64 - 1, which is 18,446,744,073,709,551,615.
                        // Max value is extremely large, practically enough for sign-in counts unless considering applications running for geological timescales.
                        // Initial value will be 0, incrementing with each successful sign-in. Represented in memory as 8 bytes, using little-endian or big-endian based on system architecture.
    active: bool, // User's account activity status (1.4). Data type bool (boolean, true or false).  Represents account being active or inactive.
                   // Typically stored as 1 byte (though logically 1 bit is enough). `true` usually represented as 1, `false` as 0 in memory. Affects user permissions and access within the application.
                   //  Edge case:  What happens if 'active' is unexpectedly changed in the database directly (outside of application logic)? Potential data inconsistency issue.
} // End of struct definition (1)

fn main() { // Main function execution starts here (2)
    // Instantiate a struct of type 'User' and bind it to the mutable variable 'user1' (2.1).
    let user1 = User {
        email: String::from("user@example.com"), // Initialize 'email' field with a String allocated on the heap. "user@example.com" is 19 bytes (ASCII).
        username: String::from("rustacean42"), // Initialize 'username' field. "rustacean42" is 11 bytes.
        active: true, // Initialize 'active' field to boolean 'true' (represented as 1 in memory).
        sign_in_count: 1, // Initialize 'sign_in_count' to unsigned 64-bit integer 1 (0x0000000000000001 in hexadecimal).
    }; // Struct instantiation complete. Memory is allocated for user1 struct fields on stack and heap (for Strings).

    // Print user information to the console using println! macro (2.2).
    println!("User {} has email {}", user1.username, user1.email);
    // Output will be: "User rustacean42 has email user@example.com".
    // String interpolation happens at runtime. Formatting involves retrieving username and email from user1's memory location and converting them to displayable strings.
} // End of main function scope (2). Memory for 'user1' is deallocated at the end of main function scope except heap allocated Strings which will be freed by Rust's ownership rules when user1 is no longer in scope.

impl User { // Implementation block for struct 'User'. Allows defining associated functions and methods for 'User' (3).
    // Associated function (similar to static methods in other languages) 'new' (3.1). Acts as a constructor for 'User'.
    fn new(email: String, username: String) -> User { // Takes 'email' and 'username' of type String as input, returns a 'User' instance.
        User { // Returns a new 'User' struct (3.1.1).
            email: email, // Initialize 'email' field with input 'email'. Ownership of input 'email' is moved into the struct.
            username: username, // Initialize 'username' field with input 'username'. Ownership moved as well.
            active: true, // 'active' is set to 'true' by default for new users. Boolean true, 1 in memory.
            sign_in_count: 0, // 'sign_in_count' initialized to 0 for new users. Integer 0, 0x00 in memory.
        } // End of User struct instantiation within 'new' function (3.1.1).
    } // End of associated function 'new' (3.1).

    // Method 'deactivate' (3.2). Operates on an instance of 'User'.
    fn deactivate(&mut self) { // Takes a mutable reference to the 'User' instance ('&mut self').  Mutable reference allows modifying the 'User' instance.
        self.active = false; // Modifies the 'active' field of the 'User' instance to 'false'. Boolean false, 0 in memory.
    } // End of method 'deactivate' (3.2).
} // End of implementation block for 'User' (3).

fn main() { // Another main function. Rust allows multiple main functions, but only one `main` function will be the program entry point. This example contains multiple for demonstration, which is likely an artifact of documentation example structuring rather than real-world multi-entry point program.
    let mut user2 = User::new( // Instantiate 'user2' by calling the associated function 'User::new' (4.1). 'mut' keyword indicates user2 can be mutated later (required for deactivate method call).
        String::from("admin@rust.org"), // First argument: email string. "admin@rust.org" is 16 bytes. Heap allocated String.
        String::from("admin") // Second argument: username string. "admin" is 5 bytes. Heap allocated String.
    ); // 'user2' is now a 'User' instance with default 'active' (true) and 'sign_in_count' (0) from 'new' function.

    user2.deactivate(); // Call the method 'deactivate' on 'user2' (4.2). '&mut self' of 'deactivate' implicitly takes a mutable borrow of 'user2'. This method call will change 'user2.active' to false.
    println!("Account active: {}", user2.active); // Print the value of 'user2.active' (4.3).
    // Output: "Account active: false" as 'deactivate' was just called. Value retrieved directly from 'user2.active' boolean memory location.
} // End of main function scope (4). 'user2' and its associated heap memory (Strings) will be deallocated.

enum WebEvent { // Define an enum named 'WebEvent' (5). Enum represents a value that can be one of several possible variants.
    PageLoad, // Variant 'PageLoad' (5.1). Represents a page load event. Unit variant, holds no additional data. Stored internally perhaps as an integer representing the variant's index (e.g., 0).
    PageUnload, // Variant 'PageUnload' (5.2). Represents page unload event. Another unit variant. Internally perhaps represented as index 1.
    KeyPress(char), // Variant 'KeyPress' (5.3). Represents a key press event, carrying a 'char' data. Character is UTF-32 encoded, usually 4 bytes in memory (can vary depending on compiler optimisations). e.g., KeyPress('A') would store the char 'A' (Unicode code point U+0041, 0x41 in hex).
    Paste(String), // Variant 'Paste' (5.4). Represents a paste event, carrying a 'String' data (pasted text). String, as discussed before, is heap allocated with dynamic size. If pasted text is "Hello", ~36 bytes.
    Click { x: i64, y: i64 }, // Variant 'Click' (5.5). Represents a click event with named fields 'x' and 'y' of type 'i64' (signed 64-bit integer).
                              // 'x' and 'y' likely represent screen coordinates. Each i64 is 8 bytes. Click {x: 100, y: 200} would store two 8-byte integers, totalling 16 bytes + enum variant overhead. Range of i64: -2^63 to 2^63 - 1.

} // End of enum 'WebEvent' definition (5).  Rust compiler internally represents enums using discriminant values (like indices).  Memory footprint of enum varies based on the largest variant's data size and whether Rust can optimize based on variant representation (like Option optimization).

fn inspect(event: WebEvent) { // Function 'inspect' (6). Takes a 'WebEvent' enum instance as input (moved into function scope unless WebEvent is Copy, which it is not).
    match event { // 'match' expression (6.1). Control flow based on the variant of the 'event' enum. Exhaustive matching required (all variants must be handled).
        WebEvent::PageLoad => println!("page loaded"), // Match arm for 'PageLoad' variant (6.2). If 'event' is 'PageLoad', print "page loaded". No extra data to access for this variant.
        WebEvent::PageUnload => println!("page unloaded"), // Match arm for 'PageUnload' variant (6.3). Prints "page unloaded".
        WebEvent::KeyPress(c) => println!("pressed '{}'", c), // Match arm for 'KeyPress' variant (6.4). Binds the 'char' data held by 'KeyPress' variant to the variable 'c'. Then prints "pressed 'c'", interpolating the value of 'c'.
        WebEvent::Paste(s) => println!("pasted \"{}\"", s), // Match arm for 'Paste' variant (6.5). Binds the 'String' data held by 'Paste' variant to the variable 's'. Prints "pasted \"s\"", interpolating the value of 's'. Ownership of the String 's' is moved into this scope if it was not borrowed.
        WebEvent::Click { x, y } => { // Match arm for 'Click' variant (6.6). Destructures the named fields 'x' and 'y' from 'Click' variant.
            println!("clicked at x={}, y={}", x, y); // Prints "clicked at x=x_value, y=y_value", interpolating the values of 'x' and 'y'.
        } // End of match arm for 'Click' (6.6).
    } // End of match expression (6.1).
} // End of function 'inspect' (6).  If 'event' was not Copy, the ownership of the event has been transferred to the 'inspect' function, and then dropped at the end of this function's scope (unless moved again inside, which isn't the case here).

fn main() { // Another main function - program entry point if this is the one compiled. (7)
    let click = WebEvent::Click { x: 20, y: 80 }; // Instantiate a 'WebEvent' enum as variant 'Click' (7.1). Initialize 'x' to 20 (0x14 in hex) and 'y' to 80 (0x50 in hex) (i64 values, each 8 bytes).
    inspect(click); // Call the 'inspect' function, passing 'click' as argument (7.2). 'click' is moved to 'inspect' function.
    // Output of inspect(click) call (from inside inspect function and the 'Click' match arm): "clicked at x=20, y=80".
} // End of main function (7). 'click' variable (and associated data inside WebEvent::Click if any were heap allocated, in this case just i64s which are on stack if 'click' itself is on stack) is dropped at the end of scope but 'click' already moved to `inspect`.

enum Shape { // Define an enum 'Shape' (8). Represents different geometric shapes.
    Circle(f64), // Variant 'Circle' (8.1). Holds a single f64 (64-bit floating point number) representing the radius. 8 bytes. Example: Circle(3.0). f64 precision approximately 15-16 decimal digits.
    Rectangle(f64, f64), // Variant 'Rectangle' (8.2). Holds two f64 values representing width and height. Total 16 bytes of data (8 bytes for width + 8 bytes for height). Example: Rectangle(4.5, 2.0).
    Triangle(f64, f64, f64), // Variant 'Triangle' (8.3). Holds three f64 values for the lengths of three sides a, b, c. Total 24 bytes of data (3 * 8 bytes). Example: Triangle(3.0, 4.0, 5.0). Constraint for triangle validity: a + b > c, a + c > b, b + c > a. Not enforced by the enum itself.
} // End of enum 'Shape' definition (8). Enum variant size determined by largest data-carrying variant (Triangle in this case, 24 bytes + discriminant).

struct Geometry { // Define a struct 'Geometry' (9). Represents a geometric shape with a color.
    shape: Shape, // Field 'shape' (9.1). Type 'Shape' enum. Can hold Circle, Rectangle, or Triangle variants. Size depends on the active 'Shape' variant - potentially up to size of Triangle variant in 'Shape' enum plus discriminant size.
    color: String, // Field 'color' (9.2). Type String. Stores the color name as a string (UTF-8 encoded, heap allocated). Example: "red". If color is "blue", ~37 bytes (~32 String overhead + 4 bytes "blue" characters approximation in ASCII).
} // End of struct 'Geometry' definition (9). Total size will be roughly size of 'Shape' enum plus size of 'String' 'color' field and struct metadata.

impl Geometry { // Implementation block for struct 'Geometry' (10). Define methods for 'Geometry' structs.
    fn area(&self) -> f64 { // Method 'area' (10.1). Takes immutable reference '&self' to a 'Geometry' instance. Returns an f64 representing the calculated area.
        match self.shape { // 'match' expression on 'self.shape' (10.1.1). Determine the shape variant and calculate area accordingly.
            Shape::Circle(radius) => 3.14159 * radius * radius, // Match arm for 'Shape::Circle' (10.1.2). Calculates circle area: π * r^2. Approximates pi as 3.14159. radius * radius is radius squared. Multiplication of f64 values results in f64. Example: if radius is 2.0, area = 3.14159 * 2.0 * 2.0 = 12.56636. Potential precision loss with floating point calculations.
            Shape::Rectangle(w, h) => w * h, // Match arm for 'Shape::Rectangle' (10.1.3). Calculates rectangle area: width * height. Multiplication of f64 values gives f64 result. Example: if w=5.0, h=2.5, area = 5.0 * 2.5 = 12.5.
            Shape::Triangle(a, b, c) => { // Match arm for 'Shape::Triangle' (10.1.4). Calculates triangle area using Heron's formula.
                let s = (a + b + c) / 2.0; // Calculate semi-perimeter 's': s = (a+b+c)/2.0. Sum and division are floating-point operations. Example: if a=3, b=4, c=5, s = (3+4+5)/2.0 = 6.0.
                (s * (s - a) * (s - b) * (s - c)).sqrt() // Apply Heron's formula: Area = sqrt(s * (s-a) * (s-b) * (s-c)). Subtractions, multiplications and square root operation, all on f64. Example (for a=3, b=4, c=5, s=6): area = sqrt(6 * (6-3) * (6-4) * (6-5)) = sqrt(6 * 3 * 2 * 1) = sqrt(36) = 6.0. Requires inclusion of sqrt function, likely from standard library or math crate.
            } // End of Triangle area calculation (10.1.4).
        } // End of match expression on 'self.shape' (10.1.1).
    } // End of method 'area' (10.1).
} // End of implementation block for 'Geometry' (10).
```