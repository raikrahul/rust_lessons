---
layout: default
title: "Lesson 5: Free Space "
date: 2024-01-30
categories: rust
permalink: /lesson5/
---

## Rust

```rust








```

## C++ Implementation

```cpp
// C++ implementation will be added here

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

void ReportError(LPCTSTR msg, DWORD exitCode, BOOL exitProgram);
void ReportSpace(LPCTSTR Message);

int _tmain(int argc, LPTSTR argv[]) {
    HANDLE hFile;
    LARGE_INTEGER FileLen, FileLenH;
    BYTE Buffer[256];
    OVERLAPPED ov = {0};
    DWORD nWrite;

    while (1) {
        FileLen.QuadPart = 0;
        _tprintf(_T("Enter file length in bytes (0 to quit): "));
        _tscanf_s(_T("%I64d"), &FileLen.QuadPart);
        
        if (FileLen.QuadPart == 0)
            break;
        
        _tprintf(_T("\nRequested file size: %,20I64d bytes\n"), FileLen.QuadPart);
        FileLenH.QuadPart = FileLen.QuadPart / 2;

        ReportSpace(_T("Before file creation"));

        hFile = CreateFile(_T("TempTestFile"), GENERIC_READ | GENERIC_WRITE, 0, NULL,
                           CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            ReportError(_T("Cannot create TempTestFile"), 2, TRUE);
        ReportSpace(_T("After file creation"));

        if (!SetFilePointerEx(hFile, FileLen, NULL, FILE_BEGIN))
            ReportError(_T("Cannot set file pointer"), 3, TRUE);

        if (!SetEndOfFile(hFile))
            ReportError(_T("Cannot set end of file"), 4, TRUE);
        ReportSpace(_T("After setting file length"));

        ov.Offset = FileLenH.LowPart;
        ov.OffsetHigh = FileLenH.HighPart;

        if (!WriteFile(hFile, Buffer, sizeof(Buffer), &nWrite, &ov))
            ReportError(_T("Cannot write to middle of file"), 5, TRUE);
        ReportSpace(_T("After writing to middle"));

        CloseHandle(hFile);
        DeleteFile(_T("TempTestFile"));
        _tprintf(_T("\n----------------------------------------\n"));
    }
    
    _tprintf(_T("\nEnd of FreeSpace demonstration\n"));
    return 0;
}

void ReportError(LPCTSTR msg, DWORD exitCode, BOOL exitProgram) {
    LPVOID lpMsgBuf;
    DWORD dw = GetLastError();

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL, dw, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)&lpMsgBuf, 0, NULL);

    _tprintf(_T("\nERROR [%d]: %s\n"), dw, (LPCTSTR)lpMsgBuf);
    LocalFree(lpMsgBuf);

    if (exitProgram) {
        ExitProcess(exitCode);
    }
}

void ReportSpace(LPCTSTR Message) {
    ULARGE_INTEGER FreeBytes, TotalBytes, NumFreeBytes;
    const double GB = 1024.0 * 1024.0 * 1024.0;

    if (!GetDiskFreeSpaceEx(NULL, &FreeBytes, &TotalBytes, &NumFreeBytes))
        ReportError(_T("Cannot get free space"), 1, TRUE);

    _tprintf(_T("\n%25s status:\n"), Message);
    _tprintf(_T("  Total disk space:   %12.2f GB\n"), (double)TotalBytes.QuadPart / GB);
    _tprintf(_T("  Actual free space:  %12.2f GB\n"), (double)NumFreeBytes.QuadPart / GB);
    _tprintf(_T("  Available to user:  %12.2f GB\n"), (double)FreeBytes.QuadPart / GB);
}
```

### Exercise

Let us implement this for small disks and observe, in C++23 or C++20. 

